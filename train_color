import torch
from torch.utils.data import DataLoader, sampler
from torch.optim import Adam
import datasets
import color_net
import numpy as np

epochs = 1000
batch_size = 100


class TrainColor(object):
    def __init__(self, epochs=1000, batch_size=100, latent_dim=12, num_bands=6):
        self.ds = datasets.ColorData()
        self.vae = color_net.ColorNet(latent_dim=latent_dim, num_bands=num_bands)

        tt_split = int(0.1 * len(ds))  # len(ds) = number of images?
        test_indices = np.mgrid[:tt_split]  # 10% of data only is for test.
        train_indices = np.mgrid[tt_split:len(ds)]

        self.optimizer = Adam(self.vae.parameters(), lr=lr, weight_decay=1e-6)
        self.test_loader = DataLoader(self.ds, batch_size=batch_size,
                                      num_workers=2, pin_memory=True,
                                      sampler=sampler.SubsetRandomSampler(test_indices))
        self.train_loader = DataLoader(self.ds, batch_size=batch_size,
                                       num_workers=2, pin_memory=True,
                                       sampler=sampler.SubsetRandomSampler(train_indices))

    def save_props(self):
        pass

    def progress(self):

    def train_one(self, data):
        loss = vae.loss(data)

        self.optimizer.zero_grad()  # clears the gradients of all optimized torch.Tensors
        loss.backward()
        self.optimizer.step()  # only part where weights are changed.
        return loss.item()


def train_epoch(vae, train_loader, optimizer):
    vae.train()  # set in training mode.
    avg_loss = 0.0

    for batch_idx, data in enumerate(train_loader):

    avg_loss /= len(train_loader.sampler)
    return avg_loss


def eval_epoch(vae, data_loader):
    vae.eval()  # set in evaluation mode = no need to compute gradients or allocate memory for them.
    avg_loss = 0.0

    with torch.no_grad():  # no need to compute gradients outside training.
        for batch_idx, data in enumerate(data_loader):
            loss = vae.loss(data)
            avg_loss += loss.item()  # gets number from tensor containing single value.

    avg_loss /= len(data_loader.sampler)
    return avg_loss


def main():
    vae.cuda()

    print('training...')


if __name__ == '__main__':
    main()
